#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the current branch name
branch="$(git symbolic-ref --short HEAD 2>/dev/null)"
if [ $? -ne 0 ]; then
    echo -e "${RED}ERROR: Not on any branch. Detached HEAD state detected.${NC}"
    exit 1
fi

# Protected branches
protected_branches=('main' 'master' 'release' 'production' 'develop')

# Check if current branch is protected
is_protected=false
for protected_branch in "${protected_branches[@]}"; do
    if [ "$branch" = "$protected_branch" ]; then
        is_protected=true
        break
    fi
done

if [ "$is_protected" = true ]; then
    echo -e "${RED}ğŸš« ERROR: Direct commits to '$branch' branch are not allowed!${NC}"
    echo -e "${YELLOW}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    echo -e "${YELLOW}â”‚            Protected Branch Workflow                â”‚${NC}"
    echo -e "${YELLOW}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
    echo -e "${BLUE}1. Create a new feature branch:${NC}"
    echo -e "   git checkout -b feat/your-feature-name"
    echo -e "   git checkout -b bugfix/your-bugfix-name"
    echo -e ""
    echo -e "${BLUE}2. Standard workflow:${NC}"
    echo -e "   git add ."
    echo -e "   git commit -m 'feat/fix: your message'"
    echo -e "   git push origin your-branch-name"
    echo -e ""
    echo -e "${RED}Emergency Override (NOT RECOMMENDED):${NC}"
    echo -e "   git commit --no-verify"
    echo -e ""
    echo -e "${YELLOW}Remember:${NC}"
    echo -e "â€¢ Always work in feature branches"
    echo -e "â€¢ Use conventional commit messages"
    echo -e "â€¢ Push changes immediately after commit"
    exit 1
fi

# Verify branch naming convention
branch_pattern="^(feat|feature|bugfix|docs|style|refactor|test|chore)/.+"
if [[ ! $branch =~ $branch_pattern ]]; then
    echo -e "${RED}ğŸš« ERROR: Invalid branch name format${NC}"
    echo -e "${YELLOW}Branch name must follow the convention:${NC}"
    echo -e "â€¢ feat/feature-name   ${GREEN}(for new features)${NC}"
    echo -e "â€¢ feature/feature-name ${GREEN}(for new features)${NC}"
    echo -e "â€¢ bugfix/bug-name     ${GREEN}(for bug fixes)${NC}"
    echo -e "â€¢ docs/change-name    ${GREEN}(for documentation)${NC}"
    echo -e "â€¢ refactor/name       ${GREEN}(for code refactoring)${NC}"
    echo -e "â€¢ style/change-name   ${GREEN}(for styling changes)${NC}"
    echo -e "â€¢ test/suite-name     ${GREEN}(for testing changes)${NC}"
    echo -e "â€¢ chore/task-name     ${GREEN}(for maintenance tasks)${NC}"
    echo -e ""
    echo -e "${BLUE}To rename your branch:${NC}"
    echo -e "1. Create new branch with correct name:"
    echo -e "   git checkout -b feat/your-feature-name"
    echo -e ""
    echo -e "2. Move your changes:"
    echo -e "   git checkout feat/your-feature-name"
    echo -e ""
    exit 1
fi

# Run format script
./scripts/format.sh
format_exit_code=$?

# Check if formatting created any changes
if git diff --quiet; then
    echo "No formatting changes needed"
else
    echo "Formatting changes detected, staging and amending..."
    git add -A
    # Store the current head commit
    current_head=$(git rev-parse HEAD)
    # Amend the commit with the same message, bypassing hooks to avoid recursion
    git commit --amend -C HEAD --no-verify
    
    # Update format_exit_code based on the amend result
    format_exit_code=$?
    
    if [ $format_exit_code -eq 0 ]; then
        echo "âœ“ Successfully formatted and amended commit"
    else
        echo "âœ— Format amend failed"
        # Restore the original commit if amend failed
        git reset --hard $current_head
        exit 1
    fi
fi

if [ $format_exit_code -ne 0 ]; then
    echo "Format check failed. Please fix the issues before committing."
    exit 1
fi

# All checks passed
echo -e "${GREEN}âœ“ Pre-commit checks passed${NC}"
exit 0
